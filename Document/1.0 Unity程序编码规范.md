# UnityC\#程序编码规范

## 1. 目的
--------------------

为了保障AnChang项目代码的编码质量、代码可读性和易维护性，特制定本规范。
AnChang项目组的所有编码人员，如无特殊原因，均应遵循本规范的指导原则进行日常代码编写，如有特殊情况，也必须以注释进行说明。

## 2. 术语定义
--------------------

Pascal：【AxxMxx】 一种标识符大小写的方式，每个单词的首字母都大写，其余字母小写。 

Camel： 【axxMxx】一种标识符大小写的方式，第一个单词全部小写，从第二个单词开始首字母大写。

## 3. 命名规范
--------------------

### 3.1 类(结构)命名规范 【AxxMxx】
--------------------

1. 类/结构体命名，遵循Pascal命名规范。

2. 使用名词或名词短语命名类，保证类名清晰，模板类开头用T，文件名应和类名相同。

3. 类名称尽量少用或不用缩写，若使用了缩写一定要在注释中详细注明类的用途。

4. 不使用Type前缀，例如C来标识Class。例如，使用FileStream而不是CFileStream。

5. 类命名中不要使用下划线及数字。

6. 在合适的时候，可以使用单词复合来标识从某个基类继承而来，一般适用于单个基类有多个直接派生类的情况，例如XXXException。

7. 调用内部成员需要用this关键字修饰，调用基类需要用base关键字修饰，以清晰地指出使用的是哪一个层级的成员。

### 3.2 变量命名规范

--------------------

1. private & protected：【mAxxMxx】 类的private成员变量和protected成员变量，必须使用m开头的Pascal形式的全英文拼写。不允许出现数字、下划线。

2. public:【axxMxx】 类的public成员变量，必须使用Camel形式全英文拼写。

3. 函数内变量：【axxMxx】 必须使用Camel形式的全英文拼写。。

4. bool类型加is前缀修饰。


### 3.3 枚举命名规范
--------------------

1. Enum类型：【AxxMxx】对Enum类型和值都使用Pascal命名规范。

2. Enum值：【AxxMxx】

3. 不需要在类型或者枚举常量的前后加上Enum前缀。

### 3.4 函数命名规范 【AxxMxx(Xxx xx, Mxx mx)】
--------------------

1. 遵循Pascal命名规范,命名应该清晰、明确、避免过度缩写。

2. 函数或方法名应使用动词来描述该方法的作用，例如GetSize()。

3. 对于具有返回值的函数名称，应该描述出该返回值的意思，名称应当清楚地表达出要返回的时什么值。例如
```csharp
bool IsTeaFresh(Tea tea){…}//名称可以明确标识true代表茶是新鲜的
```

4. 对于返回值类型为bool的函数，命名时最好以类似Is或Should开头来定义，例如IsVisible(),ShouldClearBuffer()。

### 3.5 参数命名规范
--------------------

1. 遵循Camel命名规范。

2. 使用描述性的名称。大多数场合下，参数名称加上它的类型应该足够描述它的意义。

3. 不要使用保留的参数或基于类型的参数名字。

### 3.6 常量命名规范 【PAGE_INDEX】
----------------

1. 所有单词大写，多个单词之间用下划线隔开，比如
```csharp
public const int PAGE_INDEX = 6;
```

### 3.7 单例模式
------------

1. 命名使用_instance。

2. 对应属性使用Instance。

### 3.8 委托与事件命名规范
----------------------

1. 使用动词短语命名委托，保证委托名清晰、明确。

2. 遵循Pascal命名规范，保守使用缩写。例如：
```csharp
delegate void RaiseEventHandler(string hand);
public event RaiseEventHandler RaiseEvent;
```

### 3.9 Unity文件夹及文件命名规范 【XxxMxx】
------------------------------

1. Unity工程中的所有文件夹命名，必须使用英文全拼，遵循Pascal大小写规范。

### 3.10 Ugui节点命名
------------------------------

1. 遵循Pascal大小写规范。

2. 在名称后面加上对应控件类型，如：TipText.

## 4. 注释规范

### 4.1 代码头部注释
------------------------------

1. 文件名称：文件的名称。   
2. 功能描述：文件的功能描述与大概流程说明。   
3. 作者：创建并编写的人员。   
4. 日期：创建并编写的日期。   
5. 修改记录：若类有所修改，则需要有修改人员的名字、修改日期及修改理由。

### 4.2 函数注释
------------------------------

1. 采用“///“形式自动产生XML标签格式的注释。包括函数功能，参数含义，返回内容等。

### 4.3 类变量注释
------------------------------

1. 采用“///“形式自动产生XML标签格式的注释变量含义。

### 4.4 代码行及局部变量注释
------------------------------

1. 注释位于代码上行，使用”//”注释。若空间允许，可注释在代码后面，以Tab隔开。

除此之外，注释需遵守以下几条基本的注释规则：

1. 编写有意义的注释。

2. 不要给可读性不好的代码添加注释，而是要重写这段代码。

3. 编写的注释不要和代码相冲突。

## 5. 代码规范
------------------------------

### 5.1大括号
------------------------------

1. 大括号不建议和代码占同一行，而是另起一行并且列对齐，示例：
```csharp
if (isActive)
{
  // todo...
}
```

5.2 if-else
------------------------------

1. if-else语句的每一个代码块都必须位于大括号内，对于多重if语句，遵循每个else
if与首个if的缩进对齐。示例：
```csharp
if (isActive)
{
  // todo...
}
else if (isActive)
{
  // todo ...
}
else
{
  //todo ...
}
```

5.3 switch语句
------------------------------

1. 对于switch语句，每个case都应以break或其他可改变程序控制流的语句结束，比如return。通常情况下，switch、case最后都会有一个默认的default分支以break语句结束，防止在break之后添加新的case，示例：
```csharp
switch (switch_on)
{
  case 1:
    ...
    break;
  case 2:
    ...
    return;
  default:
    break;
}
```

5.4 Tab与缩进
------------------------------

1. 按照执行代码块缩进。

2. 对每一行开头的空白使用Tab而不是空格键。Tab大小设置为4个字符。

5.5程序的版式
------------------------------

1. 除以下情况应该用空行分开：

  * 函数之间应该用空行分开。

  * 用空行将代码按照逻辑片段划分。

  * 每个类声明之后应该加入空行与其他代码分开。

2. 较长的语句(\>80字符)需要分成多行书写，按照以下规则换行：

  * 优先在逗号后换行。

  * 在操作符前换行。

3. 不允许把多个短语句写在一行中，即一行只写一条语句。

4. 代码之间应该留有适当的空格，具体如下：

  * 关键字之后要留空格，例如virtual、if、while等。

  * 函数名之后不要留空格，紧跟左括号，已与关键字区别。

  * “(”向后紧跟，“)”、“，”、“;”向前紧跟，紧跟处不留空格。

  * 值操作符、比较操作符、算术操作符、逻辑操作符、位域操作符，如“=”、“+=”、“\>=”、“<=”、“+”、“\*”、“%”、“&&”、“\|\|”、“\<\<”、“\^”等二元操作符的前后应当加空格。

5.6 调试日志
------------------------------

在开发的过程中，需要打出一些临时性的日志配合开发，调试日志需要遵守以下规则：

1. 使用Unity自带的Debug.Log或者Debug.LogFormat(项目中使用ZDebug、服务器相关使用SDebug)。

2. 功能开发完毕后必须删除调试日志。

5.7变量与结构
------------------------------

1. 尽量少使用全局变量，去掉不必要的公共变量。

2. 尽量减少不必要的数据类型隐式或强制转换。

5.8 函数
------------------------------

1. 用公共接口函数时，调用者有保障调用参数符合要求的义务。作为一种防御性的编程风  
格，被调用函数也应该对传入参数做必要的安全检查。

2. 函数的规模尽量限制在100行以内（不包括注释和空行）。

3. 一个函数仅完成一种功能。

4. 检查函数所有参数与非参数的有效性。

5. 函数的返回值要清楚、明了，让使用者避免由于误用或忽视错误返回码。

## 6. 推荐编码
------------------------------
### 6.1对于经常访问的组件，使用缓存。
------------------------------

1、Unity是基于组合的开发方式，所以GetComponent是一个高频使用的函数。每次调用GetComponent时，Unity都要去遍历所有的组件来找到目标组件。每次都去查找是不必要的耗费，我们可以通过缓存的方式来避免这些不必要的开销。可以通过缓存的方法，在Start或Awake时缓存找到的对象。尽量不要在Update或FixedUpdate中使用。GameObject.Find同理。

### 6.2 对于会用来拼接的字符串，使用StringBuider。
------------------------------

c\#中的字符串是不可变更的，也就是说其内部的值在创建后是不可被变更的。每次在对字符串进行操作的时候（例如运用字符串的“加”操作），unity会新建一个字符串用来存储新的字符串，使得旧的字符串被废弃，这样就会造成内存垃圾。

1.如果一个字符串被多次利用，我们可以创建并缓存该字符串。  
2.例如如果在Text组件中，有一部分字符串需要经常改变，但是其他部分不会，则我们可以将其分为两个部分的组件。  
3.如果我们需要实时的创建字符串，用StringBuilder专为不需要进行内存分配而设计，从而减少字符串产生的内存垃圾。  
4.移除游戏中Debug.Log()

### 6.3 使用数组或ArrayList注意
------------------------------

![](./Image/6.3.png)

### 6.4 删除空Update()函数，如果没有必要每帧调用，可以隔几帧处理。
------------------------------

![](./Image/6.4.png)

### 6.5 在Update OnGui等实时调用的函数中减少使用临时变量。
------------------------------

![](./Image/6.5-1.png)

可改为

![](./Image/6.5-2.png)


